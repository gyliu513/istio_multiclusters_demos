#!/bin/bash

set +e
set -x

. ./config.sh

CLUSTER_A_NAME=`echo $CLUSTER_A | tr A-Z a-z` # Lower case of context name
CLUSTER_B_NAME=`echo $CLUSTER_B | tr A-Z a-z` # Lower case of context name

create_ns()
{
    kubectl create namespace istio-system --context=$CLUSTER_A
    kubectl create namespace istio-system --context=$CLUSTER_B
}

setup_root_ca() 
{
    # Launch a standalone Citadel
    kubectl apply -f $ADMIN_CLUSTER_DIR/root-ca/istio-citadel-standalone.yaml --context=$ROOT_CA_CTX
    kubectl wait pod -listio=standalone-citadel -n istio-system --for condition=ready --context=$ROOT_CA_CTX

    # Create a ServiceAccount for each cluster. This will cause the standalone Citadel to create secret
    # for those ServiceAccounts with a common root CA.
    kubectl create serviceaccount istio-citadel-service-account-$CLUSTER_A_NAME \
        --context $ROOT_CA_CTX -n istio-system
    kubectl create serviceaccount istio-citadel-service-account-$CLUSTER_B_NAME \
        --context $ROOT_CA_CTX -n istio-system

    sleep 30 #Let the secrets for the above service accounts be generated by Citadel

    # Extract for the generated secrets of each cluster the keys/certs and load them into the destination
    # cluster as a Root CA secret.
    provision_cluster_int_ca.sh $ROOT_CA_CTX $CLUSTER_A $CLUSTER_A_NAME
    provision_cluster_int_ca.sh $ROOT_CA_CTX $CLUSTER_B $CLUSTER_B_NAME

    # Get the Service IP of the standalone Citadel
    ROOT_CA_IP=`kubectl --context ${ROOT_CA_CTX} get service standalone-citadel-ilb -n istio-system -o jsonpath='{.status.loadBalancer.ingress[0].ip}'`

    # Create a service that points to the standalone Citadel in each cluster
    sed -e "s/__ROOTCA_ADDR__/$ROOT_CA_IP/g" $ADMIN_CLUSTER_DIR/root-ca/istio-standalone-service.yaml | \
        kubectl  --context=$CLUSTER_A apply -f -

    sed -e "s/__ROOTCA_ADDR__/$ROOT_CA_IP/g" $ADMIN_CLUSTER_DIR/root-ca/istio-standalone-service.yaml | \
        kubectl  --context=$CLUSTER_B apply -f -

    # Update the ClusterRole for the standalone citadel so that in cases when it is installed on the same
    # cluster of Istio it won't generate secrets together with the Istio control plane Citadel.
    kubectl apply -f $ADMIN_CLUSTER_DIR/root-ca/updated-clusterrole.yaml --context=$ROOT_CA_CTX
}

setup_istio()
{
    # Cluster A
    # Install Istio
    sed -e "s/__INGRESS_GATEWAY_TYPE__/LoadBalancer/g" \
        -e "s/__CLUSTERNAME__/$CLUSTER_A_NAME/g" \
        $ISTIO_FILE_NAME | kubectl --context=$CLUSTER_A apply -f -
    # Install CoreDNS
    kubectl apply -f $ADMIN_CLUSTER_DIR/cluster-a/coredns.yaml --context=$CLUSTER_A
    
    # Cluster B
    # Install Istio
    if [ $CLUSTER_B_TYPE = "ICP" ]; then
        INGRESS_B_TYPE="NodePort"
    else
	    INGRESS_B_TYPE="LoadBalancer"
    fi
    sed -e "s/__INGRESS_GATEWAY_TYPE__/$INGRESS_B_TYPE/g" \
        -e "s/__CLUSTERNAME__/$CLUSTER_B_NAME/g" \
        $ISTIO_FILE_NAME | kubectl --context=$CLUSTER_B apply -f -
    # Install CoreDNS
    kubectl apply -f $ADMIN_CLUSTER_DIR/cluster-b/coredns.yaml --context=$CLUSTER_B
}

configure_cross_cluster()
{
    # Cluster A
    CORE_DNS_IP=`kubectl get svc core-dns -n istio-system -o jsonpath='{.spec.clusterIP}' --context=$CLUSTER_A`
    if [ $CLUSTER_B_TYPE = "ICP" ]; then
        INGRESS_B_IP=`kubectl get svc istio-ingressgateway -n istio-system -o jsonpath='{.spec.clusterIP}' --context=$CLUSTER_B`
        INGRESS_B_PORT=`kubectl get svc istio-ingressgateway -n istio-system -o jsonpath='{.spec.ports[?(@.name=="http2")].port}' --context=$CLUSTER_B`
    else
	    INGRESS_B_IP=`kubectl get svc istio-ingressgateway -n istio-system -o jsonpath='{.status.loadBalancer.ingress[*].ip}' --context=$CLUSTER_B`
	    INGRESS_B_PORT=80
    fi
	sed -e "s/INGRESS_IP_ADDRESS/$INGRESS_B_IP/g" \
	    -e "s/INGRESS_PORT/$INGRESS_B_PORT/g" \
		-e "s/CORE_DNS_IP/$CORE_DNS_IP/g" \
		$ADMIN_CLUSTER_DIR/cluster-a/cross-cluster.yaml | kubectl --context=$CLUSTER_A apply -f -

    # Cluster B
    CORE_DNS_IP=`kubectl get svc core-dns -n istio-system -o jsonpath='{.spec.clusterIP}' --context=$CLUSTER_B`
    INGRESS_A_IP=`kubectl get svc istio-ingressgateway -n istio-system -o jsonpath='{.status.loadBalancer.ingress[*].ip}' --context=$CLUSTER_A`
	INGRESS_A_PORT=80
	sed -e "s/INGRESS_IP_ADDRESS/$INGRESS_A_IP/g" \
	    -e "s/INGRESS_PORT/$INGRESS_A_PORT/g" \
		-e "s/CORE_DNS_IP/$CORE_DNS_IP/g" \
		$ADMIN_CLUSTER_DIR/cluster-b/cross-cluster.yaml | kubectl  --context=$CLUSTER_B apply -f -
}

test_app()
{
    if [ "$MANUAL_INJECTION" = true ]; then
        kubectl apply --context=$CLUSTER_A -f <(../istioctl kube-inject -f $TEST_SERVER_DIR/cluster-a/app.yaml)
        kubectl apply --context=$CLUSTER_B -f <(../istioctl kube-inject -f $TEST_SERVER_DIR/cluster-b/app.yaml)
    else
        kubectl apply --context=$CLUSTER_A -f $TEST_SERVER_DIR/cluster-a/app.yaml
        kubectl apply --context=$CLUSTER_B -f $TEST_SERVER_DIR/cluster-b/app.yaml
    fi
}

# Start executing the installation script

echo "Installing Istio with standalone Citadel.."
create_ns
setup_root_ca
setup_istio

echo
echo "Make sure all Istio pods are up and running on both clusters before continuing."
echo "Press any key to continue.."
read -n 1 -s

echo "Configuring cross-cluster.."
configure_cross_cluster

echo "Installing the test app.."
test_app
